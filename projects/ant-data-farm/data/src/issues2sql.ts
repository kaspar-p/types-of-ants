import lodash from "lodash";
import dotenv from "dotenv";
import postgres from "postgres";
import { z } from "zod";
import { readFileSync, writeFileSync } from "node:fs";
import assert from "node:assert";
// import { execSync } from "node:child_process";

import { sanitizeForSql, toSqlDate } from "./sql.js";
import { randomUUID } from "node:crypto";

type Issue = {
  author: { id: string; login: string; name: string; is_bot: boolean };
  body: string;
  closed: boolean;
  closedAt: string | null;
  createdAt: string;
  comments: {
    id: string;
    author: {
      login: string;
    };
    body: string;
    createdAt: string;
  }[];
  id: string;
  labels: { id: string; name: string; description: string; color: string }[];
  number: number;
  state: string;
  title: string;
};

const IssueSchema: z.ZodType<Issue> = z.object({
  author: z.object({
    id: z.string(),
    login: z.string(),
    name: z.string(),
    is_bot: z.boolean(),
  }),
  comments: z.array(
    z.object({
      id: z.string(),
      author: z.object({
        login: z.string(),
      }),
      body: z.string(),
      createdAt: z.string(),
    })
  ),
  body: z.string(),
  closed: z.boolean(),
  closedAt: z.string().nullable(),
  createdAt: z.string(),
  id: z.string(),
  labels: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      description: z.string(),
      color: z.string(),
    })
  ),
  number: z.number(),
  state: z.string(),
  title: z.string(),
});

const IssueFileSchema = z.array(IssueSchema);

type Ant = {
  antContent: string;
  createdAt: string;
  author: { id: string; login: string; name: string };
  comments: {
    githubId: string;
    authorLogin: string;
    body: string;
    createdAt: string;
  }[];
  state: { state: "OPEN" } | { state: "CLOSED"; closedAt: string };
};

const parseAutogeneratedTitleForAnt = (title: string): string => {
  const regex = /\`([.\s\S]*)\`/;

  switch (title) {
    case "Add 6krill ant (embed the link for 6krill.com)":
      return "6krill ant";
    case "Add trumpeter ant":
      return "trumpeter ant";
    default:
      const content = assertExpr(regex.exec(title), title)[1];
      return content;
  }
};

const assertExpr = <T>(x: T, msg?: string): NonNullable<T> => {
  assert.ok(x, msg);
  return x;
};

const ant = (issue: Issue, content?: string): { isAnt: true; ant: Ant } => {
  return {
    isAnt: true,
    ant: {
      antContent: content ?? parseAutogeneratedTitleForAnt(issue.title),
      createdAt: issue.createdAt,
      author: issue.author,
      comments: issue.comments.map((c) => ({
        githubId: c.id,
        authorLogin: c.author.login,
        body: c.body,
        createdAt: c.createdAt,
      })),
      state:
        issue.state === "OPEN"
          ? { state: "OPEN" }
          : {
              state: "CLOSED",
              closedAt: assertExpr(issue.closedAt, JSON.stringify(issue)),
            },
    },
  };
};

const isAnt = (issue: Issue): boolean => {
  const hasAutogeneratedLabel = issue.labels.some(
    (l) => l.id === "LA_kwDOHNDUrs7yF8_M"
  );

  const hasAutogeneratedInTitle = issue.title.includes("<autogenerated>");

  return hasAutogeneratedLabel || hasAutogeneratedInTitle;
};

const issueToAnt = (
  issue: Issue
): ({ isAnt: false } | { isAnt: true; ant: Ant })[] => {
  if (isAnt(issue)) {
    return [ant(issue)];
  } else {
    const hardcoded: Record<string, string[]> = {
      I_kwDOHNDUrs5IELst: ["anteatereater ant"],
      I_kwDOHNDUrs5IEMyj: ["carpenter ant", "fire ant"],
      I_kwDOHNDUrs5IENwF: ["bullet ant"],
      I_kwDOHNDUrs5IWXY1: ["ant that would date me if i was a worm"],
      I_kwDOHNDUrs5ZfwPJ: ["ant that would love to work for amazon :)"],
    };

    const override = hardcoded[issue.id];
    if (override) {
      return override.map((override) => ant(issue, override));
    }

    return [{ isAnt: false }];
  }
};

const antId = (content: string): string => {
  return `(select ant.ant_id from ant left join ant_release on ant.ant_id = ant_release.ant_id where suggested_content = '${sanitizeForSql(
    content
  )}' or ant_content = '${sanitizeForSql(content)}' limit 1)`;
};

const userId = (authorName: string): string => {
  return `(select user_id from registered_user where user_name = '${authorName}' limit 1)`;
};

const antToSql = (
  issue: Issue,
  ant: Ant
): {
  antSqlRow: string;
  declinedAntSqlRow?: string;
  commentSqlRows: string[];
} => {
  const commentSql = (comments: Ant["comments"]): string[] => {
    return comments.map((comment) => {
      const authorUserName = "nobody";
      assert.ok(
        authorUserName,
        `Could not find user from GitHub login: ${comment.authorLogin}`
      );

      return `(${antId(ant.antContent)}, '${comment.githubId}', ${userId(
        authorUserName
      )}, '${sanitizeForSql(comment.body)}', '${toSqlDate(
        comment.createdAt
      )}', '${toSqlDate(comment.createdAt)}')`;
    });
  };

  const authorUserName = "nobody";
  assert.ok(
    authorUserName,
    `Could not find user from GitHub login: ${ant.author.login}`
  );

  const antSqlRow: string = `(${userId(authorUserName)}, '${toSqlDate(
    ant.createdAt
  )}', '${sanitizeForSql(ant.antContent)}')`;

  let declinedAntSqlRow: string | undefined = undefined;
  if (issue.closed) {
    assert.ok(issue.closedAt);

    declinedAntSqlRow = `(${antId(ant.antContent)}, ${userId(
      authorUserName
    )}, '${toSqlDate(issue.closedAt)}')`;
  }

  return {
    antSqlRow,
    commentSqlRows: commentSql(ant.comments),
    declinedAntSqlRow,
  };
};

const main = async () => {
  // execSync(
  //   "gh issue list -L 10000 -s all -R kaspar-p/types-of-ants \
  //   --json assignees,author,body,closed,closedAt,comments,createdAt,id,labels,milestone,number,state,title \
  //   > 00-issues.json"
  // );

  const issues = IssueFileSchema.parse(
    JSON.parse(readFileSync("tmp/00-issues.json", { encoding: "utf8" }))
  );

  const ants = Object.values(
    issues
      .flatMap((issue) => issueToAnt(issue).flatMap((ant) => ({ issue, ant })))
      .filter((ant) => ant.ant.isAnt)
      .map((ant) => {
        assert.ok(ant.ant.isAnt);
        return { issue: ant.issue, ant: ant.ant.ant };
      })
      .reduce((acc: Record<string, { ant: Ant; issue: Issue }>, cur) => {
        acc[cur.ant.antContent] = cur;
        return acc;
      }, {})
  );

  writeFileSync("tmp/01-ants.json", JSON.stringify(ants, null, 2));

  const cfg: Record<string, string> = dotenv.parse(
    readFileSync("../../../secrets/prod/build.cfg")
  );

  const readSecret = (name: string): string => {
    return readFileSync(`../../../secrets/prod/${name}`, { encoding: "utf-8" })
      .toString()
      .trim();
  };

  const sql = postgres({
    database: readSecret("postgres_db.secret"),
    user: readSecret("postgres_user.secret"),
    host: cfg.ANT_DATA_FARM_HOST,
    port: parseInt(cfg.ANT_DATA_FARM_PORT),
    password: readSecret("postgres_password.secret"),
  });

  const antsDatabase = await Promise.all(
    ants.map(async (ant) => {
      const antIdRows: postgres.RowList<postgres.Row[]> = await sql`
        select ant.ant_id
        from
          ant left join ant_release on ant.ant_id = ant_release.ant_id
        where
          ant.suggested_content = ${ant.ant.antContent} or
          ant_release.ant_content = ${ant.ant.antContent}
        limit 1`;
      const antId: string | undefined = antIdRows?.[0]?.ant_id;

      if (antId) {
        const antDeclined: postgres.RowList<postgres.Row[]> = await sql`
         select 1 as ret from ant_declined where ant_id = ${antId} limit 1
         `;

        const ret: number | string | undefined = antDeclined?.[0]?.ret;
        if (ret === "1" || ret === 1) {
          return { ant, antId, isDeclined: true };
        }
      }

      return { ant, antId, isDeclined: false };
    })
  );

  writeFileSync(
    "tmp/02-ant-database.json",
    JSON.stringify(antsDatabase, null, 2)
  );
  writeFileSync(
    "tmp/03-not-db-ants.json",
    JSON.stringify(
      antsDatabase.filter((ant) => !ant.antId),
      null,
      2
    )
  );

  const sqlMigrationRows = antsDatabase
    .filter((ant) => !ant.antId)
    .map((ant) => {
      assert.ok(ant.antId === undefined);

      return antToSql(ant.ant.issue, ant.ant.ant);
    });

  const sqlMigration: string = `BEGIN;
  
insert into ant
  (ant_user_id, created_at, suggested_content)
values
${sqlMigrationRows
  .map(({ antSqlRow }) => antSqlRow)
  .map((r) => "  " + r)
  .join(",\n")}
;

insert into ant_declined
  (ant_id, ant_declined_user_id, ant_declined_at)
values
${sqlMigrationRows
  .map((sql) => sql.declinedAntSqlRow)
  .filter((sql) => !!sql)
  .map((r) => "  " + r)
  .join(",\n")}
;

insert into ant_comment
  (ant_id, github_comment_id, user_id, body, created_at, updated_at)
values
${sqlMigrationRows
  .flatMap((c) => c.commentSqlRows)
  .map((r) => "  " + r)
  .join(",\n")}
;

insert into migration (migration_label)
values
  ('backport-all-issues-as-ants')
;

COMMIT;
`;

  writeFileSync("tmp/04-migration.sql", sqlMigration);

  sql.end();
};

main().catch((e) => {
  throw e;
});
